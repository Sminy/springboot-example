## 总结

### 1 如何在大量的数据中找出不重复的数？

**问题描述：**

在2.5亿个整数中找出不重复的数，注意，内存不足以容纳2.5亿个整数。

分析解读：

方法一：分治法

采用hash的方法，把这2.5亿个数划分到更小的文件中，从而保证每个文件的大小不超过可用内存的大小。然后对于每个小文件而言，所有的数据可以一次性被加载到内存中，因此可以使用字典或set来找到每个小文件中不重复的数。当处理完所有的文件后就可以找出这2.5亿个整数中所有的不重复的数。

方法二：位图法

对于整数相关的算法的求解，位图法是一种非常实用的算法。如果可用的内存空间超过1GB就可以使用这种方法。具体思路：假设整数占用4B（如果占用8B，那么求解思路类似，只不过需要占用更大的内存），4B也就32位，可以表示的整数的个数为2^32.由于题目中只查找不重复的数，而不关心具体数字出现的次数，因此可以分别使用2bit来表示各个数字的状态：用00表示这个数字没有出现过，01表示出现过一次，10表示出现过多次，11暂不使用。

根据上面的逻辑，在遍历这2.5亿个整数的时候，如果这个整数对应的位图的位为00，那么修改为01，如果为01那么改为10，如果为10则保持不变。这样当所有数据遍历完成后，可以再遍历一遍位图，位图为01的数字就是没有重复的数字。



### 2 如何查看定位OOM 内存溢出代码位置？

参见《线上OOM 问题排查》



### 3 mybatis如何保证一次性导出大数据，不内存溢出的问题？

mybatis流失查询



### 4 hashmap 扩容机制是什么？

问题：最大长度7，hashmap 的初始化长度应该是多少？

答：**JDK会默认帮我们计算一个相对合理的值当做初始容量。所谓合理值，其实是找到第一个比用户传入的值大的2的幂。**所以最大长度4，那么初始化长度应该为8；

**但是，这个值看似合理，实际上并不尽然。因为HashMap在根据用户传入的capacity计算得到的默认容量，并没有考虑到loadFactor这个因素，只是简单机械的计算出第一个大约这个数字的2的幂。**



Q: hashmap 什么时候扩容呢？

S: 在不考虑hash 碰撞的情况下; 当存储数组的容量大于扩容阈值时会进行扩容；

阈值 threshold   = 	threshold = capacity * loadFactor，capacity 为数组容量，loadFactor 为负载因子；

```
loadFactor是负载因子，当HashMap中的元素个数（size）超过 threshold = loadFactor * capacity时，就会进行扩容。

公式：return (int) ((float) expectedSize / 0.75F + 1.0F);
计算：7/0.75 + 1 = 10
所以10经过jdk处理后会变成16
实际应用：
Map<String, String> map = Maps.newHashMapWithExpectedSize(7);
```

